"use strict";

// Helper functions for accessing the Facebook Graph API.
const httpsRequest = require('./httpsRequest');

var Parse = require('parse/node').Parse;

const crypto = require('crypto');

function getAppSecretPath(authData, options = {}) {
  const appSecret = options.appSecret;

  if (!appSecret) {
    return '';
  }

  const appsecret_proof = crypto.createHmac('sha256', appSecret).update(authData.access_token).digest('hex');
  return `&appsecret_proof=${appsecret_proof}`;
} // Returns a promise that fulfills iff this user id is valid.


function validateAuthData(authData, options) {
  return graphRequest('me?fields=id&access_token=' + authData.access_token + getAppSecretPath(authData, options)).then(data => {
    if (data && data.id == authData.id || process.env.TESTING && authData.id === 'test') {
      return;
    }

    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');
  });
} // Returns a promise that fulfills iff this app id is valid.


async function validateAppId(appIds, authData, options) {
  var access_token = authData.access_token;

  if (process.env.TESTING && access_token === 'test') {
    return;
  }

  if (!Array.isArray(appIds)) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'appIds must be an array.');
  }

  if (!appIds.length) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is not configured.');
  }

  const data = await graphRequest(`app?access_token=${access_token}${getAppSecretPath(authData, options)}`);

  if (!data || !appIds.includes(data.id)) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');
  }
} // A promisey wrapper for FB graph requests.


function graphRequest(path) {
  return httpsRequest.get('https://graph.facebook.com/' + path);
}

module.exports = {
  validateAppId: validateAppId,
  validateAuthData: validateAuthData
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9BZGFwdGVycy9BdXRoL2ZhY2Vib29rLmpzIl0sIm5hbWVzIjpbImh0dHBzUmVxdWVzdCIsInJlcXVpcmUiLCJQYXJzZSIsImNyeXB0byIsImdldEFwcFNlY3JldFBhdGgiLCJhdXRoRGF0YSIsIm9wdGlvbnMiLCJhcHBTZWNyZXQiLCJhcHBzZWNyZXRfcHJvb2YiLCJjcmVhdGVIbWFjIiwidXBkYXRlIiwiYWNjZXNzX3Rva2VuIiwiZGlnZXN0IiwidmFsaWRhdGVBdXRoRGF0YSIsImdyYXBoUmVxdWVzdCIsInRoZW4iLCJkYXRhIiwiaWQiLCJwcm9jZXNzIiwiZW52IiwiVEVTVElORyIsIkVycm9yIiwiT0JKRUNUX05PVF9GT1VORCIsInZhbGlkYXRlQXBwSWQiLCJhcHBJZHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpbmNsdWRlcyIsInBhdGgiLCJnZXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0EsTUFBTUEsWUFBWSxHQUFHQyxPQUFPLENBQUMsZ0JBQUQsQ0FBNUI7O0FBQ0EsSUFBSUMsS0FBSyxHQUFHRCxPQUFPLENBQUMsWUFBRCxDQUFQLENBQXNCQyxLQUFsQzs7QUFDQSxNQUFNQyxNQUFNLEdBQUdGLE9BQU8sQ0FBQyxRQUFELENBQXRCOztBQUVBLFNBQVNHLGdCQUFULENBQTBCQyxRQUExQixFQUFvQ0MsT0FBTyxHQUFHLEVBQTlDLEVBQWtEO0FBQ2hELFFBQU1DLFNBQVMsR0FBR0QsT0FBTyxDQUFDQyxTQUExQjs7QUFDQSxNQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZCxXQUFPLEVBQVA7QUFDRDs7QUFDRCxRQUFNQyxlQUFlLEdBQUdMLE1BQU0sQ0FDM0JNLFVBRHFCLENBQ1YsUUFEVSxFQUNBRixTQURBLEVBRXJCRyxNQUZxQixDQUVkTCxRQUFRLENBQUNNLFlBRkssRUFHckJDLE1BSHFCLENBR2QsS0FIYyxDQUF4QjtBQUtBLFNBQVEsb0JBQW1CSixlQUFnQixFQUEzQztBQUNELEMsQ0FFRDs7O0FBQ0EsU0FBU0ssZ0JBQVQsQ0FBMEJSLFFBQTFCLEVBQW9DQyxPQUFwQyxFQUE2QztBQUMzQyxTQUFPUSxZQUFZLENBQ2pCLCtCQUErQlQsUUFBUSxDQUFDTSxZQUF4QyxHQUF1RFAsZ0JBQWdCLENBQUNDLFFBQUQsRUFBV0MsT0FBWCxDQUR0RCxDQUFaLENBRUxTLElBRkssQ0FFQUMsSUFBSSxJQUFJO0FBQ2IsUUFBS0EsSUFBSSxJQUFJQSxJQUFJLENBQUNDLEVBQUwsSUFBV1osUUFBUSxDQUFDWSxFQUE3QixJQUFxQ0MsT0FBTyxDQUFDQyxHQUFSLENBQVlDLE9BQVosSUFBdUJmLFFBQVEsQ0FBQ1ksRUFBVCxLQUFnQixNQUFoRixFQUF5RjtBQUN2RjtBQUNEOztBQUNELFVBQU0sSUFBSWYsS0FBSyxDQUFDbUIsS0FBVixDQUFnQm5CLEtBQUssQ0FBQ21CLEtBQU4sQ0FBWUMsZ0JBQTVCLEVBQThDLHlDQUE5QyxDQUFOO0FBQ0QsR0FQTSxDQUFQO0FBUUQsQyxDQUVEOzs7QUFDQSxlQUFlQyxhQUFmLENBQTZCQyxNQUE3QixFQUFxQ25CLFFBQXJDLEVBQStDQyxPQUEvQyxFQUF3RDtBQUN0RCxNQUFJSyxZQUFZLEdBQUdOLFFBQVEsQ0FBQ00sWUFBNUI7O0FBQ0EsTUFBSU8sT0FBTyxDQUFDQyxHQUFSLENBQVlDLE9BQVosSUFBdUJULFlBQVksS0FBSyxNQUE1QyxFQUFvRDtBQUNsRDtBQUNEOztBQUNELE1BQUksQ0FBQ2MsS0FBSyxDQUFDQyxPQUFOLENBQWNGLE1BQWQsQ0FBTCxFQUE0QjtBQUMxQixVQUFNLElBQUl0QixLQUFLLENBQUNtQixLQUFWLENBQWdCbkIsS0FBSyxDQUFDbUIsS0FBTixDQUFZQyxnQkFBNUIsRUFBOEMsMEJBQTlDLENBQU47QUFDRDs7QUFDRCxNQUFJLENBQUNFLE1BQU0sQ0FBQ0csTUFBWixFQUFvQjtBQUNsQixVQUFNLElBQUl6QixLQUFLLENBQUNtQixLQUFWLENBQWdCbkIsS0FBSyxDQUFDbUIsS0FBTixDQUFZQyxnQkFBNUIsRUFBOEMsa0NBQTlDLENBQU47QUFDRDs7QUFDRCxRQUFNTixJQUFJLEdBQUcsTUFBTUYsWUFBWSxDQUM1QixvQkFBbUJILFlBQWEsR0FBRVAsZ0JBQWdCLENBQUNDLFFBQUQsRUFBV0MsT0FBWCxDQUFvQixFQUQxQyxDQUEvQjs7QUFHQSxNQUFJLENBQUNVLElBQUQsSUFBUyxDQUFDUSxNQUFNLENBQUNJLFFBQVAsQ0FBZ0JaLElBQUksQ0FBQ0MsRUFBckIsQ0FBZCxFQUF3QztBQUN0QyxVQUFNLElBQUlmLEtBQUssQ0FBQ21CLEtBQVYsQ0FBZ0JuQixLQUFLLENBQUNtQixLQUFOLENBQVlDLGdCQUE1QixFQUE4Qyx5Q0FBOUMsQ0FBTjtBQUNEO0FBQ0YsQyxDQUVEOzs7QUFDQSxTQUFTUixZQUFULENBQXNCZSxJQUF0QixFQUE0QjtBQUMxQixTQUFPN0IsWUFBWSxDQUFDOEIsR0FBYixDQUFpQixnQ0FBZ0NELElBQWpELENBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2ZULEVBQUFBLGFBQWEsRUFBRUEsYUFEQTtBQUVmVixFQUFBQSxnQkFBZ0IsRUFBRUE7QUFGSCxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIGFjY2Vzc2luZyB0aGUgRmFjZWJvb2sgR3JhcGggQVBJLlxuY29uc3QgaHR0cHNSZXF1ZXN0ID0gcmVxdWlyZSgnLi9odHRwc1JlcXVlc3QnKTtcbnZhciBQYXJzZSA9IHJlcXVpcmUoJ3BhcnNlL25vZGUnKS5QYXJzZTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5mdW5jdGlvbiBnZXRBcHBTZWNyZXRQYXRoKGF1dGhEYXRhLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgYXBwU2VjcmV0ID0gb3B0aW9ucy5hcHBTZWNyZXQ7XG4gIGlmICghYXBwU2VjcmV0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGFwcHNlY3JldF9wcm9vZiA9IGNyeXB0b1xuICAgIC5jcmVhdGVIbWFjKCdzaGEyNTYnLCBhcHBTZWNyZXQpXG4gICAgLnVwZGF0ZShhdXRoRGF0YS5hY2Nlc3NfdG9rZW4pXG4gICAgLmRpZ2VzdCgnaGV4Jyk7XG5cbiAgcmV0dXJuIGAmYXBwc2VjcmV0X3Byb29mPSR7YXBwc2VjcmV0X3Byb29mfWA7XG59XG5cbi8vIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgaWZmIHRoaXMgdXNlciBpZCBpcyB2YWxpZC5cbmZ1bmN0aW9uIHZhbGlkYXRlQXV0aERhdGEoYXV0aERhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdyYXBoUmVxdWVzdChcbiAgICAnbWU/ZmllbGRzPWlkJmFjY2Vzc190b2tlbj0nICsgYXV0aERhdGEuYWNjZXNzX3Rva2VuICsgZ2V0QXBwU2VjcmV0UGF0aChhdXRoRGF0YSwgb3B0aW9ucylcbiAgKS50aGVuKGRhdGEgPT4ge1xuICAgIGlmICgoZGF0YSAmJiBkYXRhLmlkID09IGF1dGhEYXRhLmlkKSB8fCAocHJvY2Vzcy5lbnYuVEVTVElORyAmJiBhdXRoRGF0YS5pZCA9PT0gJ3Rlc3QnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ0ZhY2Vib29rIGF1dGggaXMgaW52YWxpZCBmb3IgdGhpcyB1c2VyLicpO1xuICB9KTtcbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyBpZmYgdGhpcyBhcHAgaWQgaXMgdmFsaWQuXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUFwcElkKGFwcElkcywgYXV0aERhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGFjY2Vzc190b2tlbiA9IGF1dGhEYXRhLmFjY2Vzc190b2tlbjtcbiAgaWYgKHByb2Nlc3MuZW52LlRFU1RJTkcgJiYgYWNjZXNzX3Rva2VuID09PSAndGVzdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGFwcElkcykpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ2FwcElkcyBtdXN0IGJlIGFuIGFycmF5LicpO1xuICB9XG4gIGlmICghYXBwSWRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELCAnRmFjZWJvb2sgYXV0aCBpcyBub3QgY29uZmlndXJlZC4nKTtcbiAgfVxuICBjb25zdCBkYXRhID0gYXdhaXQgZ3JhcGhSZXF1ZXN0KFxuICAgIGBhcHA/YWNjZXNzX3Rva2VuPSR7YWNjZXNzX3Rva2VufSR7Z2V0QXBwU2VjcmV0UGF0aChhdXRoRGF0YSwgb3B0aW9ucyl9YFxuICApO1xuICBpZiAoIWRhdGEgfHwgIWFwcElkcy5pbmNsdWRlcyhkYXRhLmlkKSkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELCAnRmFjZWJvb2sgYXV0aCBpcyBpbnZhbGlkIGZvciB0aGlzIHVzZXIuJyk7XG4gIH1cbn1cblxuLy8gQSBwcm9taXNleSB3cmFwcGVyIGZvciBGQiBncmFwaCByZXF1ZXN0cy5cbmZ1bmN0aW9uIGdyYXBoUmVxdWVzdChwYXRoKSB7XG4gIHJldHVybiBodHRwc1JlcXVlc3QuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8nICsgcGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWxpZGF0ZUFwcElkOiB2YWxpZGF0ZUFwcElkLFxuICB2YWxpZGF0ZUF1dGhEYXRhOiB2YWxpZGF0ZUF1dGhEYXRhLFxufTtcbiJdfQ==